== Using Scopes

Koin brings a simple API to let you define instances that are tied to a limit lifetime.

=== What is a scope in general?

Scope is a fixed duration of time or method calls in which an object exists.
Another way to look at this is to think of scope as the amount of time an objectâ€™s state persists.
When the scope context ends, any objects bound under that scope cannot be injected again (they are dropped from the container).

The Scope API mainly consists of three constructs:

- `Scope Set`
- `Scope Instance`
- `Scope Definition`

=== What is a ScopeSet?

A `Scope Set` is a container for declaring the properties of a scope along with its definitions.
You can think of a `Scope Set` as a blueprint for actual `Scope Instance`s.
[source,kotlin]
----
module {
    scope(named("A Scope Name")){
        // definitions
    }
}
----

=== What is a Scope Instance?
A Scope instance is a specific instance of a specified ScopeSet.

[source,kotlin]
----
val scope1 = koin.createScope("scopeId1","A Scope Name")
val scope2 = koin.createScope("scopeId2","A Scope Name")
----

Each `Scope instance` has a unique id assigned. This id has to be unique across the whole `KoinApplication` instance.

=== Scope definition

By default in Koin, we have 3 kind of definitions:

- `single` definition, create an object that persistent with the entire container lifetime (can't be dropped).
- `factory` definition, create a new object each time. Short live. No persistence in the container (can't be shared).
- `scoped` definition, create an object that persistent tied to the associated scope lifetime.

To declare a scoped definition, use the `scoped` function like follow. A scope gathers scoped definitions as a logical unit of time:

[source,kotlin]
----
module {
    scope(named("A Scope Name")){
        scoped { Presenter() }
        // ...
    }
}
----

=== Working with a scope

A scope instance can be created with as follow: `val scope = koin.createScope("myScope")`. The "myScope" string here, is the id of your scope instance. 

To resolve a dependency using the scope we can do it like:

* `val presenter = scope.get<Presenter>()` - directly using the get/inject functions from the scope instance

We have to declare a the scope instance like follow:

[source,kotlin]
----
// create scope instance "myScope" (the scope Id) for scope "A_SCOPE_NAME" (the qualifier)
val scope = koin.createScope("myScope","A_SCOPE_NAME")
// resolve presenter instance
val presenter = scope.get<Presenter>()
----

=== Create & retrieve a scope

From a `KoinComponent` class or where you can access your Koin instance:

- `createScope(id : ScopeID, scopeName : Qualifier)` - create a closed scope instance with given id and scopeName
- `getScope(id : ScopeID)` - retrieve a previously created scope with given id
- `getOrCreateScope(id : ScopeID, scopeName : Qualifier)` - create or retrieve if already created, the closed scope instance with given id and scopeName

[IMPORTANT]
====
Make the difference between a scope instance id, which is the id to find your scope over all your scopes, and the scope name, which is the reference to the tied scope group name.
====

=== Creating scope instances

Using the id, it's then possible to have several instances of the same scope:

[source,kotlin]
----
// create an closed scope instance "myScope1" for scope "A_SCOPE_NAME"
val myScope1 = koin.createScope("myScope1",named("A_SCOPE_NAME"))
// create an closed scope instance "myScope2" for scope "A_SCOPE_NAME"
val myScope2 = koin.createScope("myScope2",named("A_SCOPE_NAME"))
----


=== Resolving dependencies within a scope

The interest of a scope is to define a common logical unit of time for scoped definitions. It's allow also to resolve definitions from within the given scope

[source,kotlin]
----
// given the classes
class ComponentA
class ComponentB(val a : ComponentA)

// module with scope
module {
    
    scope(named("A_SCOPE_NAME")){
        scoped { ComponentA() }
        // will resolve from current scope instance
        scoped { ComponentB(get()) }
    }
}
----

The dependency resolution is then straight forward:

[source,kotlin]
----
// create an closed scope instance "myScope1" for scope "A_SCOPE_NAME"
val myScope1 = koin.createScope("myScope1",named("A_SCOPE_NAME"))

// from the same scope
val componentA = myScope1.get<ComponentA>()
val componentB = myScope1.get<ComponentB>()
----

=== Closing a scope

Once your scope instance is finished, just closed it with the `close()` function:

[source,kotlin]
----
// from a KoinComponent
val session = getKoin().createScope("session")

// use it ...

// close it
session.close()
----

[IMPORTANT]
====
Beware that you can't inject instances anymore from a closed scope.
====

=== Provide dependencies on the fly

A component might have a limited lifetime, but another component might be in charge of its
instantiation where the instantiation process is not dispatched by yourself.
In this case, you can make the corresponding object available in the dependency by declaring
the dependency after the scope instance has been created.

[source,kotlin]
----
interface UserSession
class AuthenticatedUserSession: UserSession()
class AnonymousUserSession: UserSession()

module {
    scope(named("User Session")) {
        // UserSession can be resolved after `declare`
        // has been called on the scope instance
        scoped { UserSpecificService(get<UserSession>())}
    }
}

val scopeAuthenticated = koin.createScope(named("User Session"))
scopeAuthenticated.declare<UserSession>(authenticatedSession)
val scopeAnonymous = koin.createScope(named("User Session"))
scopeAnonymous.declare<UserSession>(anonymousSession)
----

=== Scope Hierarchies

During scope instance creation, the id of the parent scope can be provided.
When no id for the parent scope is specified, the root scope will be assigned as the parent scope.

[source,kotlin]
----
module {
    scope(named("Scope A")) {
        scoped { PresenterA() }
    }
    scope(named("Scope B")) {
        // Resolve based on current scope which will automatically
        // use the parent scope when no applicable definition has been found
        // in current scope
        scoped { PresenterB( get<PresenterA>()) }
    }
}

val scopeA = koin.createScope("id1", named("Scope A"))
val scopeB = koin.createScope("id2", named("Scope B"), parentId = "id1")
----

It's also possible to declare `Scope B` inside the definition of `Scope A`.
The following example provides the same result as the previous example, but its more clear
to the reader that `Scope B` is intended to exist as a child scope of `Scope A`.

[source,kotlin]
----
module {
    scope(named("Scope A")) {
        scoped { PresenterA() }
        // declaration of Scope B inside of Scope A
        nestedScope(named("Scope B")) {
            scoped { PresenterB( get<PresenterA>()) }
        }
    }
}
val scopeA = koin.createScope("id1", named("Scope A"))
val scopeB = koin.createScope("id2", named("Scope B"), parentId = "id1")
----

[IMPORTANT]
====
Beware that the resolution of `PresenterA` will fail in both examples, if the parentId for `Scope B` is not provided.
====

=== Explicit resolution of dependencies from parent scope

[source, kotlin]
----
interface Service {
    val value: String
}
class Base: Service {
    override val value = "Base"
}
class ServiceA(parent: Service): Service {
    override val value = "{parent.value} A"
}
class ServiceB(parent: Service): Service {
    override val value = "{parent.value} B"
}
----

[source, kotlin]
----
module {
    scope(named("A")) {
        scoped<Service> { Base() }

        nestedScope(named("B")) {
            // parentScope is accessible inside definition
            scoped<Service> { ServiceA(parentScope.get()) }

            nestedScope(named("C")) {
                scoped<Service> { ServiceB(parentScope.get()) }
            }
        }
    }
}
----

[source, kotlin]
----
val scopeA = koin.createScope("id1", named("A"))
val scopeB = koin.createScope("id2", named("B"), parentId = "id1")
val scopeC = koin.createScope("id3", named("C"), parentId = "id2")
// Base A B
println(scopeC.get<Service>().value)
----

=== Scope callback -- TODO


